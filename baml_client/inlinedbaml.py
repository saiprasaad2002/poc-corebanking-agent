# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\r\n\r\nclient<llm> CustomGPT4o {\r\n  provider openai\r\n  options {\r\n    model \"gpt-4o\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomGPT4oMini {\r\n  provider openai\r\n  retry_policy Exponential\r\n  options {\r\n    model \"gpt-4o-mini\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomSonnet {\r\n  provider anthropic\r\n  options {\r\n    model \"claude-3-5-sonnet-20241022\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\n\r\nclient<llm> CustomHaiku {\r\n  provider anthropic\r\n  retry_policy Constant\r\n  options {\r\n    model \"claude-3-haiku-20240307\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\r\nclient<llm> CustomFast {\r\n  provider round-robin\r\n  options {\r\n    // This will alternate between the two clients\r\n    strategy [CustomGPT4oMini, CustomHaiku]\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\r\nclient<llm> OpenaiFallback {\r\n  provider fallback\r\n  options {\r\n    // This will try the clients in order until one succeeds\r\n    strategy [CustomGPT4oMini, CustomGPT4oMini]\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/retry\r\nretry_policy Constant {\r\n  max_retries 3\r\n  // Strategy is optional\r\n  strategy {\r\n    type constant_delay\r\n    delay_ms 200\r\n  }\r\n}\r\n\r\nretry_policy Exponential {\r\n  max_retries 2\r\n  // Strategy is optional\r\n  strategy {\r\n    type exponential_backoff\r\n    delay_ms 300\r\n    multiplier 1.5\r\n    max_delay_ms 10000\r\n  }\r\n}",
    "content.baml": "class ComponentDetail {\r\n    source string @description(\"The name of the table to fetch from. Only the table names mentioned in the schema\")\r\n    crieteria string @description(\"The fiter value to pass in the to get the desired result. Should be the same as what it's present in the policy document\")\r\n    risk string? @description(\"The risk percentage, or empty if not applicable\")\r\n}\r\n                \r\nclass Parameters {\r\n    components map<string, ComponentDetail[]> \r\n        @description(\"Mapping of component name to list of details, one component can have multiple sources and multiple criterias\")\r\n    formula string \r\n        @description(\"The formula to achieve the query execution\")\r\n    planner string \r\n        @description(\"A successful plan/path\")\r\n    sql_template string \r\n        @description(\"Optimized SQL Query\")\r\n}\r\n\r\nfunction FetchResults(markdown_content: string, user_question: string) -> Parameters{\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n        # Role and Objective\r\n        - You are an advanced financial document analyzer and SQL query expert. Your mission is to extract exact financial ratio specifications from policy documents and generate accurate SQL query templates for user questions.\r\n\r\n        # Instructions\r\n        - Begin with a concise checklist (3-7 bullets) of what you will do; keep items conceptual, not implementation-level.\r\n        - Follow a strict step-by-step methodology to ensure precision and prevent information blending between different ratios.\r\n        - Extract only the directly relevant information and maintain fidelity to policy document terminology.\r\n\r\n        ## Stepwise Process\r\n\r\n        **STEP 1: RATIO IDENTIFICATION**\r\n        - Extract the exact ratio name mentioned in the user question (`{{user_question}}`).\r\n        - Output the ratio name explicitly.\r\n\r\n        **STEP 2: POLICY DOCUMENT SEARCH**\r\n        - Search only for content related to the identified ratio within the provided markdown policy document (`{{markdown_content}}`).\r\n\r\n        **STEP 3: SECTION EXTRACTION**\r\n        - Locate and quote the specific section or paragraph discussing the ratio.\r\n\r\n        **STEP 4: COMPONENT, FORMULA, AND TABLE PARSING**\r\n        - Extract only the components and the exact formula from the quoted section.\r\n        - Properly parse tables in the section—account for components with multiple sources or criteria, and map all elements precisely.\r\n        - Output components, sources, and criteria as arrays, mapping all details as they appear in the policy document.\r\n\r\n        ## Validation Stage\r\n        - Before proceeding with outputs, ensure:\r\n        - The extracted formula matches the identified ratio.\r\n        - All components correspond only to the selected ratio; there is no mixing with other financial ratios.\r\n        - Table data is parsed in full, capturing every source, component, and criterion specified.\r\n        - The names of components and sources exactly match the policy document.\r\n        - Any optional parameters are included only if the policy explicitly mentions them.\r\n\r\n        # Planning and Output Policy\r\n        - Return result only upon passing all validation checks.\r\n        - If unable to identify or validate any required piece, return the null/empty output structure immediately.\r\n\r\n        # SQL Query Planning\r\n        - Based on the extracted components, formula, and sources, provide a planner—outlining reasoning and the approach for building a SQL query strictly in accordance with the provided schema:\r\n\r\n        ### Database Schema (reference for accurate column and table usage)\r\n        - `gl_account_master(gl_acct_id, gl_account, branch, account_name, account_category, sub_category)`\r\n        - `gl_account_summary(gl_acct_id, acct_currency, ledger_balance, last_transaction_date)`\r\n        - `loan_portfolio(loan_id, branch, loan_type, loan_product, risk_weight_percentage, principal_amount, interest_rate, purpose, tenor_months, repayment_type, charge_collected, collateral_value, risk_class, outstanding_balance, accrued_interest, currency)`\r\n\r\n        {{ctx.output_format}}\r\n    \"#\r\n}",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.204.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "intent.baml": "class Intent{\r\n    valid bool\r\n}\r\n\r\nfunction CheckIntent(question: string) -> Intent {\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n        You are an expert in intent classification and your\r\n        role is a financial expert and a well-know expert in core-banking services.\r\n        Given the user's question, determine if the user's intent is relevant to any \r\n        core-banking or financial services. If the intent is relevant, return\r\n        valid as true otherwise return valid as false.\r\n        Question: {{question}}\r\n\r\n        {{ctx.output_format}}\r\n    \"#\r\n}",
    "resume.baml": "// Defining a data model.\r\nclass Resume {\r\n  name string\r\n  email string\r\n  experience string[]\r\n  skills string[]\r\n}\r\n\r\n// Create a function to extract the resume from a string.\r\nfunction ExtractResume(resume: string) -> Resume {\r\n  // Specify a client as provider/model-name\r\n  // you can use custom LLM params with a custom client name from clients.baml like \"client CustomHaiku\"\r\n  client \"openai/gpt-4o\" // Set OPENAI_API_KEY to use this client.\r\n  prompt #\"\r\n    Extract from this content:\r\n    {{ resume }}\r\n\r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n\r\n\r\n// Test the function with a sample resume. Open the VSCode playground to run this.\r\ntest vaibhav_resume {\r\n  functions [ExtractResume]\r\n  args {\r\n    resume #\"\r\n      Vaibhav Gupta\r\n      vbv@boundaryml.com\r\n\r\n      Experience:\r\n      - Founder at BoundaryML\r\n      - CV Engineer at Google\r\n      - CV Engineer at Microsoft\r\n\r\n      Skills:\r\n      - Rust\r\n      - C++\r\n    \"#\r\n  }\r\n}\r\n",
    "tools.baml": "enum Tools{\r\n    @@dynamic\r\n}\r\n\r\nclass Toolvalidation{\r\n    valid bool\r\n    tool_name string[]?\r\n    description string[]?\r\n    reasoning string? @description(\"The reasoning behind the tool validation\")\r\n}\r\n\r\nclass Invocations{\r\n    tool_name string\r\n    parameters string[] | int[] @description(\"string parameters should be stored as string datatype and for numbers, it should be stored as int datatype\")\r\n}\r\n\r\nclass ClarityCheck{\r\n    clarity bool\r\n    functioncall Invocations[]? @description(\"The respective function names and the parameters for it is defined here\")\r\n    reasoning string? @description(\"The reasoning behind the clarity check decision\")\r\n}\r\n\r\nfunction ValidateToolCalling(user_question: string, tools:string[], description: string[],user_role:string) -> Toolvalidation {\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n        You are an expert in tool validation and your\r\n        role is a financial expert and a well-know expert in core-banking services.\r\n        Given the user's question, determine if the tool calling is valid or not.\r\n        If the user's question fall under one of those valid tools to be called then return valid as true and give the tool_name to be called and it's respective description (which contains the parameters mandatorily required by the function (tool) to be called) as it is without any modification.\r\n        Even if the parameters don't match but the tool call can be achieved with the user's question, then give the reasoning to it.\r\n        If the user's question doesn't fall under any of those valid tools are needed, return valid as false.\r\n\r\n        There are some tools which are specific to only certain roles. Check with the description and the user role and decide the validity\r\n        User role: {{user_role}}\r\n        Question: {{user_question}}\r\n\r\n        Allowed Tools:\r\n        {% for tool in tools %}\r\n            -{{tool}}\r\n        {% endfor %}\r\n\r\n        Descriptions:\r\n        {% for description in description%}\r\n            -{{description}}\r\n        {% endfor %}\r\n\r\n        {{ctx.output_format}}\r\n    \"#\r\n}\r\n\r\nfunction Claritycheckfunction(user_question:string, tools:string[], description:string[],user_role:string) -> ClarityCheck {\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n        You are an expert in clarity checking and your\r\n        role is a financial expert and a well-know expert in core-banking services.\r\n        Given the user's question, the tool to be called and the description of the tool which contains the parameters mandatorily required by the function (tool) to be called\r\n        determine if the user's question is clear enough containing the parameters required by the function to be called\r\n        If the user's question is clear enough, return clarity as true, give the tool name to be called and extract the parameters from the user's question\r\n        If the user's question is not clear enough, return clarity as false and give the reasoning behind the clarity check decision\r\n        Question: {{user_question}}\r\n        Tool to be called: {% for tool in tools %}\r\n            -{{tool}}\r\n        {% endfor %}\r\n        Description of the tool: {{description}}\r\n        User role: {{user_role}}\r\n        {{ctx.output_format}}\r\n    \"#\r\n}",
}

def get_baml_files():
    return _file_map