# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\r\n\r\nclient<llm> CustomGPT4o {\r\n  provider openai\r\n  options {\r\n    model \"gpt-4o\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomGPT4oMini {\r\n  provider openai\r\n  retry_policy Exponential\r\n  options {\r\n    model \"gpt-4o-mini\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomSonnet {\r\n  provider anthropic\r\n  options {\r\n    model \"claude-3-5-sonnet-20241022\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\n\r\nclient<llm> CustomHaiku {\r\n  provider anthropic\r\n  retry_policy Constant\r\n  options {\r\n    model \"claude-3-haiku-20240307\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\r\nclient<llm> CustomFast {\r\n  provider round-robin\r\n  options {\r\n    // This will alternate between the two clients\r\n    strategy [CustomGPT4oMini, CustomHaiku]\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\r\nclient<llm> OpenaiFallback {\r\n  provider fallback\r\n  options {\r\n    // This will try the clients in order until one succeeds\r\n    strategy [CustomGPT4oMini, CustomGPT4oMini]\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/retry\r\nretry_policy Constant {\r\n  max_retries 3\r\n  // Strategy is optional\r\n  strategy {\r\n    type constant_delay\r\n    delay_ms 200\r\n  }\r\n}\r\n\r\nretry_policy Exponential {\r\n  max_retries 2\r\n  // Strategy is optional\r\n  strategy {\r\n    type exponential_backoff\r\n    delay_ms 300\r\n    multiplier 1.5\r\n    max_delay_ms 10000\r\n  }\r\n}",
    "content.baml": "class ComponentDetail {\r\n    source string @description(\"The name of the table to fetch from. Only the table names mentioned in the schema\")\r\n    crieteria string? @description(\"The fiter value to pass in the to get the desired result. Should be the same as what it's present in the policy document\")\r\n    risk string? @description(\"The risk percentage, or empty if not applicable\")\r\n}\r\n                \r\nclass Parameters {\r\n    valid bool @description(\"Validate if the user's question is relevant to the markdown content or not\")\r\n    components map<string, ComponentDetail[]>?\r\n        @description(\"Mapping of component name to list of details, one component can have multiple sources and multiple criterias\")\r\n    formula string?\r\n        @description(\"The formula to achieve the query execution\")\r\n    planner string?\r\n        @description(\"A successful plan/path\")\r\n}\r\n\r\nfunction FetchResults(markdown_content: string, user_question: string) -> Parameters{\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n# Role and Objective\r\n- You are an advanced financial document analyzer and SQL query expert. Your mission is to thoroughly analyze both structured and unstructured markdown policy documents and extract contents that are strongly relevant to the user's question about financial ratios.\r\n\r\n# Instructions\r\n- Start by evaluating the validity (relevancy) of the user's question with the markdown content presented. Strongly check for a direct and explicit link between the user's question and the provided policy document content. If there is high relevancy, return the result as \"True\" and proceed. If not, return \"False\" and do not proceed with content extraction.\r\n- Do not extract any components or policy document content unless the user's question is found to be explicitly and strongly relevant to the markdown content.\r\n- Begin with a concise checklist (3-7 bullets) of conceptual steps to take; avoid implementation-level detail.\r\n- Ensure a robust, iterative step-by-step methodology to guarantee only highly relevant content is extracted, with strict adherence to preventing blending between different ratios or irrelevant information.\r\n- Work with both structured and unstructured markdown content by fully reviewing the entire policy document for the most strongly relevant sections.\r\n- Use policy document terminology exactly: strictly match all component, source, criteria, and formula names to the policy.\r\n- When extracting the source name for each component from the policy document, ensure the source is matched against the given database schema tables (for example, if the policy document mentions GL as the source, it should be mapped to `gl_account_master`, `gl_account_summary`, or both, depending upon components required by the calculation).\r\n\r\n## Stepwise Process\r\n\r\n**STEP 0: VALIDITY (RELEVANCY) CHECK**\r\n- Evaluate if the user's question about a financial ratio is directly and explicitly relevant to the content in the policy document (`{{markdown_content}}`).\r\n- If strong relevancy is not established, immediately return \"False\" and do not proceed.\r\n- If the question is found valid and relevant, return \"True\" and continue with the detailed extraction process.\r\n\r\n**STEP 1: RATIO IDENTIFICATION**\r\n- Extract the exact financial ratio name as mentioned in the user question (`{{user_question}}`).\r\n- State the identified ratio name explicitly.\r\n\r\n**STEP 2: COMPREHENSIVE POLICY DOCUMENT ANALYSIS**\r\n- Iterate through the entire provided markdown policy document (`{{markdown_content}}`), regardless of structure, searching for text or sections that are strongly and directly relevant to the ratio in the user question.\r\n- Apply strong iterative extraction and validation at each step to avoid inclusion of any loosely related or extraneous information.\r\n\r\n**STEP 3: RELEVANT SECTION EXTRACTION**\r\n- Quote only those specific sections, passages, or paragraphs that have clear, direct association with the identified financial ratio.\r\n\r\n**STEP 4: COMPONENT, FORMULA, SOURCE, AND CRITERIA EXTRACTION**\r\n- For each relevant quoted section, extract and map:\r\n  - `component`: Every part of the formula derived from the policy document for the selected ratio.\r\n  - `source`: The database table or entity from which each component must be retrieved. The extracted source name must be correlated and mapped to the correct table(s) in the provided database schema. If the policy uses an ambiguous or shorthand name (e.g., GL), you must determine the appropriate schema table(s) (e.g., `gl_account_master`, `gl_account_summary`, or both) for each component as required for accurate database retrieval.\r\n  - `criteria`: Clear filters or conditions stated in the policy for each component when retrieving from the source.\r\n  - `formula`: The complete calculation or relationship among components as specified.\r\n- Account for multiple sources, criteria, or component details, mirroring everything as stated in the policy document.\r\n- Output components, sources, criteria, and formulas as arrays or objects to capture the exact structure and detail.\r\n\r\n## Validation Stage\r\n- Before any output, rigorously validate:\r\n- The extracted formula strictly matches the identified ratio.\r\n- Components, sources (matching to schema tables), and criteria are exclusively associated with the selected ratio, with no cross-mixing.\r\n- Every relevant detail in tables, text, or figures is fully captured and mapped.\r\n- Names and terms for sources/components exactly mirror those in the policy document and are appropriately mapped to the schema.\r\n- Optional parameters or criteria are included only if unambiguously stated in the policy document.\r\n- Repeat iterations and reviews if any ambiguity or irrelevance is detected, to ensure only content of the highest relevance is included.\r\n\r\n# Planning and Output Policy\r\n- Return a result only once all validation checks for strong relevance, question validity, and precision are passed.\r\n- Return a result only once all validation checks for strong relevance and precision are passed.\r\n- If any piece cannot be identified, validated, or found to be strongly relevant, return the null/empty output structure immediately.\r\n\r\n# SQL Query Planning\r\n- Based on the extracted and validated components, formula, sources (mapped and aligned to specific tables in the provided schema), and criteria, propose a clear planner. This planner should explain the reasoning and precise steps for building an accurate SQL query. The plan must clearly specify the source name(s) as matched to the schema, the components, criteria, and formula, describing in detail how the database query operation should proceed to fulfill policy requirements and user questions.\r\n\r\n### Database Schema (reference for accurate column and table usage for source extraction)\r\n- `gl_account_master(gl_acct_id, gl_account, branch, account_name, account_category, sub_category)`\r\n- `gl_account_summary(gl_acct_id, acct_currency, ledger_balance, last_transaction_date)`\r\n- `loan_portfolio(loan_id, branch, loan_type, loan_product, risk_weight_percentage, principal_amount, interest_rate, purpose, tenor_months, repayment_type, charge_collected, collateral_value, risk_class, outstanding_balance, accrued_interest, currency)`\r\n\r\n{{ctx.output_format}}\r\n    \"#\r\n}\r\n\r\nclass SqlQuery {\r\n    sql_query string @description(\"The final optimized SQL Query\")\r\n}\r\n\r\nfunction SqlQueryGenerator(components: Parameters) -> SqlQuery{\r\n    client CustomSonnet\r\n    prompt #\"\r\n# Role and Objective\r\n- You are an advanced SQL query generator. Your inputs are objects that include extracted policy components, sources, criteria, formulas, and a planner, all based on prior financial document analysis and mapped to a given database schema. Your task is to use this structured extraction and the policy/calculation logic to construct a single, highly accurate SQL query answering the user's ratio question.\r\n\r\n# Inputs\r\n- You will be provided with an object: {{components}}\r\n- This object contains the following:\r\n  - `components`: All relevant financial formula components, with their associated sources (schema tables), criteria and risk (if any)\r\n  - `formula`: The calculation or combination required among the components.\r\n  - `planner`: Step-by-step reasoning/methodology for constructing the query and applying sources, components, and formula. Pay particular attention to the planner, following its detailed step-by-step instructions closely during SQL query construction.\r\n- Database schema definitions are provided below.\r\n\r\n# Output Instructions\r\n- Using only the provided object (`components`, `source`, `criteria`, `risk (if any)`, `formula`, `planner`) and the supplied database schema, generate the final SQL query that answers the ratio calculation as described.\r\n- Use the precise mapping of components to schema tables and strictly honor all detailed criteria and calculation logic described in the input object and planner.\r\n- Ensure that any joins, filters, aggregations, or calculations respect the criteria and source information for each component.\r\n- You must strongly consider and prioritize the use of the LIKE wildcard operator in your SQL queries whenever filters are involved, especially in scenarios where formatting or punctuation inconsistencies may exist in the database table values for those columns. The LIKE operator should be applied wherever necessary to robustly handle potential edge cases and ensure accurate filtering, except where an exact match is certain. Do not omit this step.\r\n- Your output should be only the SQL query. Do not output any explanation, planner, or descriptionâ€”just the SQL code block.\r\n\r\n# SQL Query Generation Steps\r\n1. Parse each component and its associated source(s)/criteria strictly in accordance with the planner.\r\n2. For components with different sources, use appropriate JOINs or UNIONs as needed, ensuring each step in the planner is followed exactly and in the sequence outlined by the planner and schema.\r\n3. Apply all criteria to filtering, WHERE clauses, or CASE statements for risk weightings (as needed by formula/planner), precisely reflecting planner instructions.\r\n4. Implement aggregation and formula calculation exactly as described (e.g., summing tiers, risk weighting assets, combining numerator/denominator conditions), strictly adhering to the methodology provided in the planner.\r\n5. Output only the final SQL query, ready to execute.\r\n\r\n\r\n# Reference Database Schema\r\n- `gl_account_master(gl_acct_id, gl_account, branch, account_name, account_category, sub_category)`\r\n- `gl_account_summary(gl_acct_id, acct_currency, ledger_balance, last_transaction_date)`\r\n- `loan_portfolio(loan_id, branch, loan_type, loan_product, risk_weight_percentage, principal_amount, interest_rate, purpose, tenor_months, repayment_type, charge_collected, collateral_value, risk_class, outstanding_balance, accrued_interest, currency)`\r\n\r\n# Output Format\r\n- Output the final SQL query as a single code block, nothing else.\r\n{{ctx.output_format}}\r\n    \"#\r\n}\r\n\r\nclass Response{\r\n    response_string string\r\n}\r\n\r\nfunction SqlResult(user_question:string, sql_result:string) -> Response{\r\n    client CustomSonnet\r\n    prompt #\"\r\n        You're an expert at briefing the sql query execution result to the user, according to\r\n        what user has asked. Here's the user asked question: {{user_question}} and \r\n        here's the sql query result: {{sql_result}}\r\n\r\n        {{ctx.output_format}}\r\n    \"#\r\n}",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.205.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "intent.baml": "class Intent{\r\n    valid bool\r\n}\r\n\r\nfunction CheckIntent(question: string) -> Intent {\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n        You are an expert in intent classification and your\r\n        role is a financial expert and a well-know expert in core-banking services.\r\n        Given the user's question, determine if the user's intent is relevant to any \r\n        core-banking or financial services. If the intent is relevant, return\r\n        valid as true otherwise return valid as false.\r\n        Question: {{question}}\r\n\r\n        {{ctx.output_format}}\r\n    \"#\r\n}",
    "resume.baml": "// Defining a data model.\r\nclass Resume {\r\n  name string\r\n  email string\r\n  experience string[]\r\n  skills string[]\r\n}\r\n\r\n// Create a function to extract the resume from a string.\r\nfunction ExtractResume(resume: string) -> Resume {\r\n  // Specify a client as provider/model-name\r\n  // you can use custom LLM params with a custom client name from clients.baml like \"client CustomHaiku\"\r\n  client \"openai/gpt-4o\" // Set OPENAI_API_KEY to use this client.\r\n  prompt #\"\r\n    Extract from this content:\r\n    {{ resume }}\r\n\r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n\r\n\r\n// Test the function with a sample resume. Open the VSCode playground to run this.\r\ntest vaibhav_resume {\r\n  functions [ExtractResume]\r\n  args {\r\n    resume #\"\r\n      Vaibhav Gupta\r\n      vbv@boundaryml.com\r\n\r\n      Experience:\r\n      - Founder at BoundaryML\r\n      - CV Engineer at Google\r\n      - CV Engineer at Microsoft\r\n\r\n      Skills:\r\n      - Rust\r\n      - C++\r\n    \"#\r\n  }\r\n}\r\n",
    "router.baml": "class Route{\r\n    tool string\r\n}\r\n\r\nfunction DefineRoute(user_question: string) -> Route{\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n        You're an expert at routing the user question to the available routes, having their specific tool names (which is defined below)\r\n        Analyse the user question and define the route accordingly. If you couldn't identify the tool from the user question, then return the tool \"invalid\"\r\n        User Question: {{user_question}}\r\n\r\n        Tools:\r\n        gl_info (\"To fetch the information about a specific general ledger\")\r\n        loan_info (\"To fetch the information about a specific loan account\")\r\n        ratios (\"To fetch the ratios such as CRAR, Liquidity, etc\")\r\n        invalid (\"Out of context/less relevant tool\")\r\n\r\n        {{ctx.output_format}}\r\n\r\n    \"#\r\n}\r\n\r\ntest TestName {\r\n  functions [DefineRoute]\r\n  args {\r\n    user_question #\"\r\n      What's the liquidity ratio\r\n    \"#\r\n  }\r\n}\r\n",
    "tools.baml": "enum Tools{\r\n    @@dynamic\r\n}\r\n\r\nclass Toolvalidation{\r\n    valid bool\r\n    tool_name string[]?\r\n    description string[]?\r\n    reasoning string? @description(\"The reasoning behind the tool validation\")\r\n}\r\n\r\nclass Invocations{\r\n    tool_name string\r\n    parameters string[] | int[] @description(\"string parameters should be stored as string datatype and for numbers, it should be stored as int datatype\")\r\n}\r\n\r\nclass ClarityCheck{\r\n    clarity bool\r\n    functioncall Invocations[]? @description(\"The respective function names and the parameters for it is defined here\")\r\n    reasoning string? @description(\"The reasoning behind the clarity check decision\")\r\n}\r\n\r\nfunction ValidateToolCalling(user_question: string, tools:string[], description: string[],user_role:string) -> Toolvalidation {\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n        You are an expert in tool validation and your\r\n        role is a financial expert and a well-know expert in core-banking services.\r\n        Given the user's question, determine if the tool calling is valid or not.\r\n        If the user's question fall under one of those valid tools to be called then return valid as true and give the tool_name to be called and it's respective description (which contains the parameters mandatorily required by the function (tool) to be called) as it is without any modification.\r\n        Even if the parameters don't match but the tool call can be achieved with the user's question, then give the reasoning to it.\r\n        If the user's question doesn't fall under any of those valid tools are needed, return valid as false.\r\n\r\n        There are some tools which are specific to only certain roles. Check with the description and the user role and decide the validity\r\n        User role: {{user_role}}\r\n        Question: {{user_question}}\r\n\r\n        Allowed Tools:\r\n        {% for tool in tools %}\r\n            -{{tool}}\r\n        {% endfor %}\r\n\r\n        Descriptions:\r\n        {% for description in description%}\r\n            -{{description}}\r\n        {% endfor %}\r\n\r\n        {{ctx.output_format}}\r\n    \"#\r\n}\r\n\r\nfunction Claritycheckfunction(user_question:string, tools:string[], description:string[],user_role:string) -> ClarityCheck {\r\n    client \"openai/gpt-4o\"\r\n    prompt #\"\r\n        You are an expert in clarity checking and your\r\n        role is a financial expert and a well-know expert in core-banking services.\r\n        Given the user's question, the tool to be called and the description of the tool which contains the parameters mandatorily required by the function (tool) to be called\r\n        determine if the user's question is clear enough containing the parameters required by the function to be called\r\n        If the user's question is clear enough, return clarity as true, give the tool name to be called and extract the parameters from the user's question\r\n        If the user's question is not clear enough, return clarity as false and give the reasoning behind the clarity check decision\r\n        Question: {{user_question}}\r\n        Tool to be called: {% for tool in tools %}\r\n            -{{tool}}\r\n        {% endfor %}\r\n        Description of the tool: {{description}}\r\n        User role: {{user_role}}\r\n        {{ctx.output_format}}\r\n    \"#\r\n}",
}

def get_baml_files():
    return _file_map